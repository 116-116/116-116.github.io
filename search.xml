<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>哈希</title>
      <link href="/2022/09/13/er-fen-tu-pan-ding-ran-se-fa/"/>
      <url>/2022/09/13/er-fen-tu-pan-ding-ran-se-fa/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-none"><code class="language-none">#include &lt;bits&#x2F;stdc++.h&gt;#define ll long longusing namespace std;const int M &#x3D; 1e5, N &#x3D; 1e5;int head[N], ed[M * 2], nex[M * 2], idx;int m, n;int color[N];void add(int a, int b)&#123;    ed[++idx] &#x3D; b;    nex[idx] &#x3D; head[a];    head[a] &#x3D; idx;&#125;bool dfs(int u, int co)&#123;    color[u] &#x3D; co;    for (int i &#x3D; head[u]; i; i &#x3D; nex[i])    &#123;        if (!color[ed[i]])        &#123;            if (dfs(ed[i], 3 - co))                return 1;        &#125;        else if (color[ed[i]] &#x3D;&#x3D; co)            return 1;    &#125;    return 0;&#125;int main()&#123;    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    for (int i &#x3D; 1; i &lt;&#x3D; m; ++i)    &#123;        int a, b;        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);        add(a, b);        add(b, a);    &#125;    int flag &#x3D; 0;    for (int i &#x3D; 1; i &lt;&#x3D; n;++i)    &#123;        if(!color[i]&amp;&amp;dfs(i,1))        &#123;            flag &#x3D; 1;            break;        &#125;    &#125;    if(flag)        cout &lt;&lt; &quot;No\n&quot;;    else        cout &lt;&lt; &quot;Yes\n&quot;;    system(&quot;pause&quot;);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 二分图判定-染色法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>匈牙利二分最大匹配</title>
      <link href="/2022/09/13/xiong-ya-li-er-fen-tu-zui-da-pi-pei/"/>
      <url>/2022/09/13/xiong-ya-li-er-fen-tu-zui-da-pi-pei/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-none"><code class="language-none">#include &lt;bits&#x2F;stdc++.h&gt;#define ll long longusing namespace std;const int N &#x3D; 50010;int n,m,p[N],vis[N];int head[N],ed[N*2],nex[N*2],idx;void add(int a,int b)&#123;    ed[idx]&#x3D;b;    nex[idx]&#x3D;head[a];    head[a]&#x3D;idx++;&#125;bool pipei(int i)&#123;    for(int j&#x3D;head[i];j!&#x3D;-1;j&#x3D;nex[j])    &#123;        if(!vis[ed[j]])        &#123;            ++vis[ed[j]];            if(!p[ed[j]]||pipei(p[ed[j]]))            &#123;                p[ed[j]]&#x3D;i;                return 1;            &#125;        &#125;    &#125;    return 0;&#125;int f()&#123;    int ans&#x3D;0;    for(int i&#x3D;1;i&lt;&#x3D;n;++i)    &#123;        memset(vis,0,(n+2)*sizeof vis[0]);        if(pipei(i))ans++;    &#125;    return ans;&#125;int main()&#123;    memset(head,-1,sizeof head);    int e,a,b;    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;e);    for(int i&#x3D;1;i&lt;&#x3D;e;++i)    &#123;        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);        add(a,b);    &#125;    cout&lt;&lt;f()&lt;&lt;endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">#include &lt;bits&#x2F;stdc++.h&gt;#define ll long longusing namespace std;const int N &#x3D; 250;int n, m, p[N], vis[N],a[N][N];bool pipei(int i)&#123;    for (int j &#x3D; 1; j &lt;&#x3D; n; ++j)    &#123;        if (a[i][j]&amp;&amp;!vis[j])        &#123;            ++vis[j];            if (!p[j] || pipei(p[j]))            &#123;                p[j] &#x3D; i;                return 1;            &#125;        &#125;    &#125;    return 0;&#125;int f()&#123;    int ans &#x3D; 0;    for (int i &#x3D; 1; i &lt;&#x3D; n; ++i)    &#123;        memset(vis, 0, (n + 2) * sizeof vis[0]);        if (pipei(i))            ans++;    &#125;    return ans;&#125;int main()&#123;    int t;    scanf(&quot;%d&quot;, &amp;t);    while (t--)    &#123;        memset(p,0,sizeof p);        scanf(&quot;%d&quot;,&amp;n);        for (int i &#x3D; 1; i &lt;&#x3D; n; ++i)        &#123;            for(int j&#x3D;1;j&lt;&#x3D;n;++j)                scanf(&quot;%d&quot;,&amp;a[i][j]);        &#125;        if(f()&#x3D;&#x3D;n)cout&lt;&lt;&quot;Yes\n&quot;;        else cout&lt;&lt;&quot;No\n&quot;;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络流-最小费用最大流-ek+spfa</title>
      <link href="/2022/09/13/wang-luo-liu-zui-xiao-fei-yong-zui-da-liu-ek-spfa/"/>
      <url>/2022/09/13/wang-luo-liu-zui-xiao-fei-yong-zui-da-liu-ek-spfa/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-none"><code class="language-none">#include&lt;bits&#x2F;stdc++.h&gt;#define ll  long longusing namespace std;const int N &#x3D; 5100,M&#x3D;100000;ll head[N], ed[M * 2], nex[M * 2], idx &#x3D; 1, val[M * 2],w[M*2];ll pre[N], mf[N]; &#x2F;&#x2F;点i的前驱边号，s-&gt;v路径的流量上限ll dis[N];int n,s,t,m;int a, b;ll c, d;int vis[N];void add(int a,int b,ll c,ll d)&#123;    ed[++idx] &#x3D; b;    val[idx] &#x3D; c;    w[idx] &#x3D; d;    nex[idx] &#x3D; head[a];    head[a] &#x3D; idx;&#125;bool spfa()&#x2F;&#x2F;找最小花费的增广路，每次找的一条路中每条边流量相同，花费&#x3D;所有边的花费之和*flow&#123;    memset(mf, 0, sizeof mf);    memset(dis, 0x3f3f, (n+5)*sizeof dis[0]);    queue&lt;int&gt; q;    q.push(s);    mf[s] &#x3D; 1e18;    dis[s] &#x3D; 0;    vis[s] &#x3D; 1;    while(q.size())    &#123;        int u &#x3D; q.front();        q.pop();        vis[u] &#x3D; 0;        for (int i &#x3D; head[u]; i;i&#x3D;nex[i])        &#123;            int v &#x3D; ed[i];            if(dis[v]&gt;dis[u]+w[i]&amp;&amp;val[i])            &#123;                dis[v] &#x3D; dis[u] + w[i];&#x2F;&#x2F;更新最短路                mf[v] &#x3D; min(mf[u], val[i]);&#x2F;&#x2F;更新最大流量                pre[v] &#x3D; i;&#x2F;&#x2F;前驱边                if(!vis[v])                &#123;                    q.push(v);                    vis[v] &#x3D; 1;                &#125;            &#125;        &#125;    &#125;    return mf[t]&gt;0;&#125;ll flow, cost;void ek()&#123;    while(spfa())    &#123;        int v &#x3D; t;        while(v!&#x3D;s)        &#123;            int i &#x3D; pre[v];            val[i] -&#x3D; mf[t];            val[i ^ 1] +&#x3D; mf[t];&#x2F;&#x2F;更新残留网            v &#x3D; ed[i ^ 1];        &#125;        flow +&#x3D; mf[t];        cost +&#x3D; mf[t] *dis[t];&#x2F;&#x2F;累加费用和可行流    &#125;&#125;int main()&#123;    scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;s, &amp;t);    for (int i &#x3D; 1; i &lt;&#x3D; m;++i)    &#123;        scanf(&quot;%d%d%d%d&quot;, &amp;a, &amp;b, &amp;c,&amp;d);        add(a, b, c,d);        add(b, a, 0,-d);    &#125;    ek();    cout &lt;&lt; flow &lt;&lt; &#39; &#39; &lt;&lt; cost &lt;&lt; endl;    &#x2F;&#x2F; system(&quot;pause&quot;);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络流最大流</title>
      <link href="/2022/09/13/wang-luo-liu-zui-da-liu-ek/"/>
      <url>/2022/09/13/wang-luo-liu-zui-da-liu-ek/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-none"><code class="language-none">#include&lt;bits&#x2F;stdc++.h&gt;#define ll  long longusing namespace std;const int N &#x3D; 210,M&#x3D;5100;ll head[N], ed[M * 2], nex[M * 2], idx &#x3D; 1, val[M * 2];ll pre[N], mf[N]; &#x2F;&#x2F;点i的前驱边号，s-&gt;v路径的流量上限ll n,s,t,m;ll a, b, c;void add(ll a,ll b,ll c)&#123;    ed[++idx] &#x3D; b;    val[idx] &#x3D; c;    nex[idx] &#x3D; head[a];    head[a] &#x3D; idx;&#125;bool bfs()&#123;    memset(mf, 0, sizeof mf);    queue&lt;int&gt; q;    q.push(s);    mf[s] &#x3D; 1e18;    while(q.size())    &#123;        int u &#x3D; q.front();        q.pop();        for (int i &#x3D; head[u]; i;i&#x3D;nex[i])        &#123;            int v &#x3D; ed[i];            if(!mf[v]&amp;&amp;val[i])            &#123;                mf[v] &#x3D; min(mf[u], val[i]);                pre[v] &#x3D; i;                q.push(v);                if(v&#x3D;&#x3D;t)                    return 1;            &#125;        &#125;    &#125;    return 0;&#125;ll ek()&#123;    ll flow &#x3D; 0;    while(bfs())    &#123;        int v &#x3D; t;        while(v!&#x3D;s)        &#123;            int i &#x3D; pre[v];            val[i] -&#x3D; mf[t];            val[i ^ 1] +&#x3D; mf[t];            v &#x3D; ed[i ^ 1];        &#125;        flow +&#x3D; mf[t];    &#125;    return flow;&#125;int main()&#123;    scanf(&quot;%lld%lld%lld%lld&quot;, &amp;n, &amp;m, &amp;s, &amp;t);    for (int i &#x3D; 1; i &lt;&#x3D; m;++i)    &#123;        scanf(&quot;%lld%lld%lld&quot;, &amp;a, &amp;b, &amp;c);        add(a, b, c);        add(b, a, 0);    &#125;    cout &lt;&lt; ek() &lt;&lt; endl;    &#x2F;&#x2F; system(&quot;pause&quot;);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络流最大流-最小割-dinic</title>
      <link href="/2022/09/13/wang-luo-liu-zui-da-liu-zui-xiao-ge-dinic/"/>
      <url>/2022/09/13/wang-luo-liu-zui-da-liu-zui-xiao-ge-dinic/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-none"><code class="language-none">#include&lt;bits&#x2F;stdc++.h&gt;#define ll  long longusing namespace std;const int N &#x3D; 210,M&#x3D;5100;ll head[N], ed[M * 2], nex[M * 2], idx &#x3D; 1, val[M * 2]; &#x2F;&#x2F; idx&#x3D;1 使编号从2，3开始  正反边通过^1可得ll dep[N],cur[N];&#x2F;&#x2F;dep存深度（层级），防止dfs搜的太深，cur存u点的当前出边ll n,s,t,m;ll a, b, c;int vis[N];&#x2F;&#x2F;记录最小割的集合void add(ll a,ll b,ll c)&#123;    ed[++idx] &#x3D; b;    val[idx] &#x3D; c;    nex[idx] &#x3D; head[a];    head[a] &#x3D; idx;&#125;bool bfs()&#123;    memset(dep, 0, (n + 2) * sizeof dep[0]);&#x2F;&#x2F;找增广路并重新分层    queue&lt;int&gt; q;    q.push(s);    dep[s] &#x3D; 1;    while(q.size())    &#123;        int u &#x3D; q.front();        q.pop();        for (int i &#x3D; head[u]; i;i&#x3D;nex[i])        &#123;            int v &#x3D; ed[i];            if(!dep[v]&amp;&amp;val[i])            &#123;                dep[v] &#x3D; dep[u] + 1;                q.push(v);                if(v&#x3D;&#x3D;t)                    return 1;            &#125;        &#125;    &#125;    return 0;&#125;ll dfs(int u,ll mf)&#x2F;&#x2F;多路增广&#123;    if(u&#x3D;&#x3D;t)        return mf;    ll sum &#x3D; 0;    for (int i &#x3D; cur[u]; i;i&#x3D;nex[i])    &#123;        cur[u] &#x3D; i;&#x2F;&#x2F;当前弧优化，之前的边已无法流通，不再遍历        int v &#x3D; ed[i];        if(dep[v]&#x3D;&#x3D;dep[u]+1&amp;&amp;val[i])        &#123;            ll f &#x3D; dfs(v, min(mf, val[i]));            val[i] -&#x3D; f;            val[i ^ 1] +&#x3D; f;&#x2F;&#x2F;更新残留网            sum +&#x3D; f;&#x2F;&#x2F;累加u点的流出流量            mf -&#x3D; f;&#x2F;&#x2F;更新u点的剩余流量            if(!mf)&#x2F;&#x2F;余量优化：u点流量耗尽，结束对u的增广                break;        &#125;    &#125;    if(!sum)&#x2F;&#x2F;残枝优化，sum&#x3D;0 此前路径无法流通可以删除        dep[u] &#x3D; 0;    return sum;&#125;ll dinic()&#x2F;&#x2F;累加可以流通的流量&#123;    ll flow &#x3D; 0;    while(bfs())    &#123;        memcpy(cur, head, (n + 5) * sizeof head[0]);        flow +&#x3D; dfs(s, 1e18);    &#125;    return flow;&#125;void mincut(int u)&#123;    vis[u] &#x3D; 1;    for (int i &#x3D; head[u]; i;i&#x3D;nex[i])    &#123;        if(!vis[ed[i]]&amp;&amp;val[i])            mincut(ed[i]);    &#125;&#125;int main()&#123;    scanf(&quot;%lld%lld%lld%lld&quot;, &amp;n, &amp;m, &amp;s, &amp;t);    for (int i &#x3D; 1; i &lt;&#x3D; m;++i)    &#123;        scanf(&quot;%lld%lld%lld&quot;, &amp;a, &amp;b, &amp;c);        add(a, b, c);        add(b, a, 0);    &#125;    cout &lt;&lt; dinic() &lt;&lt; endl;&#x2F;&#x2F;最大流-最小割    &#x2F;&#x2F; for (int i &#x3D; 1; i &lt;&#x3D; m;++i)    &#x2F;&#x2F; &#123;    &#x2F;&#x2F;     scanf(&quot;%lld%lld&quot;, &amp;a, &amp;b);    &#x2F;&#x2F;     add(a, b, 1);    &#x2F;&#x2F;     add(b, a, 0);    &#x2F;&#x2F; &#125;    &#x2F;&#x2F; cout &lt;&lt; dinic() &lt;&lt; endl;&#x2F;&#x2F;最小割的最少边数    mincut(s);    vector&lt;int&gt; s_set, t_set;&#x2F;&#x2F;最小割的划分之一    for (int i &#x3D; 1; i &lt;&#x3D; n;++i)        if(vis[i])            s_set.push_back(i);        else            t_set.push_back(i);        &#x2F;&#x2F; system(&quot;pause&quot;);        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈希</title>
      <link href="/2022/09/13/er-fen-tu-zui-da-pi-pei-dinic/"/>
      <url>/2022/09/13/er-fen-tu-zui-da-pi-pei-dinic/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-none"><code class="language-none">#include&lt;bits&#x2F;stdc++.h&gt;#define ll long longusing namespace std;const int N &#x3D; 1100,M &#x3D; 110000;int head[N], nex[M], ed[M], val[M], idx &#x3D; 1;int dep[N], cur[N];int n, m, s, t, e,a,b;void add(int a,int b,int c&#x3D;1)&#123;    ed[++idx] &#x3D; b;    val[idx] &#x3D; c;    nex[idx] &#x3D; head[a];    head[a] &#x3D; idx;&#125;bool bfs()&#123;    memset(dep, 0, sizeof dep[0] * (n+m+5));    queue&lt;int&gt; q;    q.push(s);    dep[s]&#x3D;1;    while(q.size())    &#123;        int u &#x3D; q.front();        q.pop();        for (int i &#x3D; head[u]; i;i&#x3D;nex[i])        &#123;            if(!dep[ed[i]]&amp;&amp;val[i])            &#123;                dep[ed[i]] &#x3D; dep[u] + 1;                if(ed[i]&#x3D;&#x3D;t)                    return 1;                q.push(ed[i]);            &#125;        &#125;    &#125;    return 0;&#125;ll dfs(int u,int mf)&#123;    if(u&#x3D;&#x3D;t)        return (ll)mf;    ll sum &#x3D; 0;    for (int i &#x3D; cur[u]; i;i&#x3D;nex[i])    &#123;        cur[u] &#x3D; i;        if(dep[ed[i]]&#x3D;&#x3D;dep[u]+1&amp;&amp;val[i])        &#123;            ll f&#x3D;dfs(ed[i], min(mf, val[i]));            mf -&#x3D; f;            sum +&#x3D; f;            val[i] -&#x3D; f;            val[i ^ 1] +&#x3D; f;            if(!mf)                break;        &#125;    &#125;    if(!sum)        dep[u] &#x3D; 0;    return sum;&#125;ll dinic()&#123;    ll flow &#x3D; 0;    while(bfs())    &#123;        memcpy(cur, head, (n +m+ 5) * sizeof head[0]);        flow+&#x3D;dfs(s, 1e9);    &#125;    return flow;&#125;int main()&#123;    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;e);    s &#x3D; 0;    t &#x3D; n + m + 1;    for (int i &#x3D; 1; i &lt;&#x3D; e;++i)    &#123;        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);        add(a, b + n, 1);        add(b + n, a, 0);    &#125;    for (int i &#x3D; 1; i &lt;&#x3D; n;++i)    &#123;        add(s,  i, 1);        add(i, s, 0);    &#125;    for (int i &#x3D; 1; i &lt;&#x3D; m;++i)    &#123;        add(n+i,  t, 1);        add(t, n+i, 0);    &#125;    cout &lt;&lt; dinic() &lt;&lt; endl;    &#x2F;&#x2F; system(&quot;pause&quot;);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 二分图最大匹配-dinic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lca-tarjan</title>
      <link href="/2022/09/08/lca-tarjan/"/>
      <url>/2022/09/08/lca-tarjan/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-none"><code class="language-none">#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;const int N&#x3D;10000025;int idx,head[N],ed[2*N],nex[2*N],val[N*2],head1[N],ed1[2*N],nex1[2*N],pos[N*2],idx1;void add(int a,int b,int c)&#123;    ed[idx]&#x3D;b;    nex[idx]&#x3D;head[a];    val[idx]&#x3D;c;    head[a]&#x3D;idx++;&#125;void add1(int a,int b,int c)&#123;    ed1[idx1]&#x3D;b;    nex1[idx1]&#x3D;head1[a];    pos[idx1]&#x3D;c;    head1[a]&#x3D;idx1++;&#125;int fa[N],dis[N],vis[N],f[N],m,n,ans[N];void dfs(int rt)&#123;    f[rt]&#x3D;1;    for(int i&#x3D;head[rt];i!&#x3D;-1;i&#x3D;nex[i])    &#123;        if(!f[ed[i]])        &#123;            dis[ed[i]]&#x3D;dis[rt]+val[i];            dfs(ed[i]);        &#125;    &#125;&#125;int find(int x)&#123;    return fa[x]&#x3D;&#x3D;x?x:fa[x]&#x3D;find(fa[x]);&#125;void lca_tarjan(int rt)&#123;    f[rt]&#x3D;1;    for(int i&#x3D;head[rt];i!&#x3D;-1;i&#x3D;nex[i])    &#123;        if(f[ed[i]])continue;        lca_tarjan(ed[i]);        fa[find(ed[i])]&#x3D;rt;    &#125;    vis[rt]&#x3D;1;    for(int i&#x3D;head1[rt];i!&#x3D;-1;i&#x3D;nex1[i])    &#123;        if(vis[ed1[i]])            ans[pos[i]]&#x3D;find(ed1[i]);    &#125;&#125;int main()&#123;    int s,x,y;    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;s);    memset(head ,-1,(n+20)*sizeof (head[0]));    memset(head1 ,-1,(n+20)*sizeof (head1[0]));    for(int i&#x3D;1;i&lt;&#x3D;n;++i)        fa[i]&#x3D;i;    for(int i&#x3D;1;i&lt;n;++i)    &#123;        scanf(&quot;%d%d&quot;,&amp;x,&amp;y);        add(x,y,1);        add(y,x,1);    &#125;    for(int i&#x3D;1;i&lt;&#x3D;m;++i)    &#123;        scanf(&quot;%d%d&quot;,&amp;x,&amp;y);        add1(x,y,i);        add1(y,x,i);    &#125;    dfs(s);    memset(f,0,(n+20)*sizeof f[0]);    lca_tarjan(s);    for(int i&#x3D;1;i&lt;&#x3D;m;++i)        printf(&quot;%d\n&quot;,ans[i]);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lca-树链刨分</title>
      <link href="/2022/09/07/lca-shu-lian-bao-fen/"/>
      <url>/2022/09/07/lca-shu-lian-bao-fen/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N&#x3D;500005;int dep[N],fa[N],son[N],siz[N],top[N];int head[N],ed[N*2],nex[2*N],idx;void add(int a,int b)&#123;    ed[idx]&#x3D;b;    nex[idx]&#x3D;head[a];    head[a]&#x3D;idx++;&#125;void dfs1(int x,int dad)&#123;    fa[x]&#x3D;dad;    siz[x]&#x3D;1;    son[x]&#x3D;0;    dep[x]&#x3D;dep[dad]+1;    for(int i&#x3D;head[x];i!&#x3D;-1;i&#x3D;nex[i])    &#123;        if(ed[i]&#x3D;&#x3D;dad)continue;        dfs1(ed[i],x);        siz[x]+&#x3D;siz[ed[i]];        if(siz[son[x]]&lt;siz[ed[i]])son[x]&#x3D;ed[i];    &#125;   &#125;void dfs2(int x,int topx)&#123;    top[x]&#x3D;topx;    if(son[x])dfs2(son[x],topx);    else    return;    for(int i&#x3D;head[x];i!&#x3D;-1;i&#x3D;nex[i])        if(ed[i]!&#x3D;fa[x]&amp;&amp;ed[i]!&#x3D;son[x])dfs2(ed[i],ed[i]);&#125;int lca(int x,int y)&#123;    while(top[x]!&#x3D;top[y])    &#123;        if(dep[top[x]]&lt;dep[top[y]])            swap(x,y);        x&#x3D;fa[top[x]];    &#125;    return dep[x]&lt;dep[y]?x:y;&#125;int n,m,s,x,y;int main()&#123;    memset(head,-1,sizeof head);    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;s);    for(int i&#x3D;1;i&lt;n;++i)    &#123;        scanf(&quot;%d%d&quot;,&amp;x,&amp;y);        add(x,y);        add(y,x);    &#125;    dfs1(s,0);    dfs2(s,s);    while(m--)    &#123;        scanf(&quot;%d%d&quot;,&amp;x,&amp;y);        printf(&quot;%d\n&quot;,lca(x,y));    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笛卡尔树</title>
      <link href="/2022/09/02/di-qia-er-shu/"/>
      <url>/2022/09/02/di-qia-er-shu/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;#include&lt;stack&gt;#define re register#define il inline#define LL long longusing namespace std;const int N&#x3D;10000010;int a[N],n,k;typedef struct &#123;    int fa,lson,rson,val;&#125;T;T tree[N];template&lt;typename T&gt;il void read(T &amp;ff)&#123;    T rr&#x3D;1;ff&#x3D;0;re char ch&#x3D;getchar();    while(!isdigit(ch))&#123;if(ch&#x3D;&#x3D;&#39;-&#39;)rr&#x3D;-1;ch&#x3D;getchar();&#125;    while(isdigit(ch))&#123;ff&#x3D;(ff&lt;&lt;1)+(ff&lt;&lt;3)+(ch^48);ch&#x3D;getchar();&#125;    ff*&#x3D;rr;&#125;void build()&#123;    stack&lt;int&gt;st;    st.push(1);    tree[1].val&#x3D;a[1];    for(int i&#x3D;2;i&lt;&#x3D;n;++i)    &#123;        if(a[st.top()]&gt;a[i])        &#123;            while(!st.empty()&amp;&amp;a[st.top()]&gt;a[i])k&#x3D;st.top(),st.pop();            tree[i].lson&#x3D;k;            tree[i].fa&#x3D;tree[k].fa;            tree[tree[k].fa].rson&#x3D;i;            tree[k].fa&#x3D;i;        &#125;        else        &#123;            tree[i].fa&#x3D;st.top();            tree[st.top()].rson&#x3D;i;        &#125;        tree[i].val&#x3D;a[i];        st.push(i);    &#125;&#125;int main()&#123;    read(n);    for(int i&#x3D;1;i&lt;&#x3D;n;++i)        read(a[i]);    build();    long long L&#x3D;0,R&#x3D;0;&#x2F;&#x2F;     for(int i&#x3D;1;i&lt;&#x3D;n;++i)&#x2F;&#x2F;     printf(&quot;%lld %lld\n&quot;,tree[i].lson,tree[i].rson);      for(int i&#x3D;1;i&lt;&#x3D;n;++i)        L^&#x3D;1LL*i*(tree[i].lson+1),R^&#x3D;1LL*i*(tree[i].rson+1);     printf(&quot;%lld %lld\n&quot;,L,R);    return 0;&#125;#include&lt;iostream&gt;#include&lt;stack&gt;#define re register#define il inline#define LL long longusing namespace std;const int N&#x3D;10000010;int a[N],n,k,st[N],top;typedef struct &#123;    int fa,lson,rson,val;&#125;T;T tree[N];void build()&#123;    for(int i&#x3D;1;i&lt;&#x3D;n;++i)    &#123;        k&#x3D;top;        while(k&amp;&amp;a[st[k]]&gt;a[i])--k;        if(k)tree[st[k]].rson&#x3D;i;        if(k&lt;top)tree[i].lson&#x3D;st[k+1];        st[++k]&#x3D;i;        top&#x3D;k;    &#125;&#125;template&lt;typename T&gt;il void read(T &amp;ff)&#123;    T rr&#x3D;1;ff&#x3D;0;re char ch&#x3D;getchar();    while(!isdigit(ch))&#123;if(ch&#x3D;&#x3D;&#39;-&#39;)rr&#x3D;-1;ch&#x3D;getchar();&#125;    while(isdigit(ch))&#123;ff&#x3D;(ff&lt;&lt;1)+(ff&lt;&lt;3)+(ch^48);ch&#x3D;getchar();&#125;    ff*&#x3D;rr;&#125;int main()&#123;    read(n);    for(int i&#x3D;1;i&lt;&#x3D;n;++i)        read(a[i]);    build();    long long L&#x3D;0,R&#x3D;0;    for(int i&#x3D;1;i&lt;&#x3D;n;++i)        L^&#x3D;1LL*i*(tree[i].lson+1),R^&#x3D;1LL*i*(tree[i].rson+1);     printf(&quot;%lld %lld\n&quot;,L,R);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lca-倍增</title>
      <link href="/2022/09/02/lca-bei-zeng/"/>
      <url>/2022/09/02/lca-bei-zeng/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-none"><code class="language-none">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;const int N &#x3D; 550000 + 5;vector&lt;int&gt; son[N];int T, n, m, dep[N], fa[N][30], a, b,vis[N]; &#x2F;&#x2F;后面的20代表2的多少次方  根据题意更改 a父节点，b子节点void dfs(int x, int pre) &#x2F;&#x2F; x为dfs节点 pre为其父节点&#123;    if(vis[x])        return ;    vis[x]&#x3D;1;    dep[x] &#x3D; dep[pre] + 1; &#x2F;&#x2F;计算x节点的深度    fa[x][0] &#x3D; pre;        &#x2F;&#x2F; x向上走2^0&#x3D;1步为其父节点    for (int i &#x3D; 1; (1 &lt;&lt; i) &lt;&#x3D; n; ++i)        fa[x][i] &#x3D; fa[fa[x][i - 1]][i - 1]; &#x2F;&#x2F; x向上走2^i步等同于x向上走2^(i-1)步后再走2^(i-1)步    for (int i &#x3D; 0; i &lt; son[x].size(); ++i) &#x2F;&#x2F;递归处理x的子节点        dfs(son[x][i], x);&#125;int up(int x, int d) &#x2F;&#x2F;计算x节点向上走d步的节点&#123;    int ret &#x3D; x;                        &#x2F;&#x2F;将返回值初始化为x    for (int i &#x3D; 0; (1 &lt;&lt; i) &lt;&#x3D; n; ++i) &#x2F;&#x2F;考虑d的二进制表示为1的位置，用之前预处理的值向上跳跃        if (((1 &lt;&lt; i) &amp; d) !&#x3D; 0)            ret &#x3D; fa[ret][i];    return ret;&#125;int lca(int x, int y) &#x2F;&#x2F;计算x，y的lca&#123;    if (dep[x] &lt; dep[y]) &#x2F;&#x2F;保证x为深度大的节点        swap(x, y);    x &#x3D; up(x, dep[x] - dep[y]); &#x2F;&#x2F;将x，y的深度跳为一致    if (x &#x3D;&#x3D; y)        return x;    int maxd&#x3D;log2(dep[x])+1;    for (int i &#x3D; maxd; i &gt;&#x3D; 0; --i) &#x2F;&#x2F; 19代表2的19次方 可根据题意更改        if (fa[x][i] !&#x3D; fa[y][i])            x &#x3D; fa[x][i], y &#x3D; fa[y][i];    return fa[x][0];&#125;int main()&#123;    int temp;    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;temp);    for (int i &#x3D; 1; i &lt;&#x3D; n; ++i)        son[i].clear();    for (int i &#x3D; 1; i &lt; n; ++i)    &#123;        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);        son[a].push_back(b);        son[b].push_back(a);    &#125;    dep[0] &#x3D; -1;    dfs(temp, 0);    while (m--)    &#123;        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);        printf(&quot;%d\n&quot;, lca(a, b));        &#x2F;&#x2F;printf(&quot;%d\n&quot;,dep[a]+dep[b]-2*dep[lca(a,b)]);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lca-欧拉序rmq</title>
      <link href="/2022/09/01/lca-rmq-ou-la-xu/"/>
      <url>/2022/09/01/lca-rmq-ou-la-xu/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;const int N &#x3D; 500005;vector&lt;int&gt; son[N];int n, m, dep[N], first[N], last[N], top, vis[N];int st[N * 2][40]; &#x2F;&#x2F; 20大小根据题意可改动void dfs(int x, int d)&#123;    ++top, st[top][0] &#x3D; x; &#x2F;&#x2F;将x加入欧拉序中    first[x] &#x3D; top;        &#x2F;&#x2F;记录x第一次出现的位置    vis[x] &#x3D; 1;    for (int i &#x3D; 0; i &lt; son[x].size(); ++i)    &#123;        if (!vis[son[x][i]])        &#123;            dfs(son[x][i], d + 1); &#x2F;&#x2F;递归子节点            ++top;            st[top][0] &#x3D; x; &#x2F;&#x2F;回溯到x后 x加入欧拉序中        &#125;    &#125;    dep[x] &#x3D; d;    last[x] &#x3D; top; &#x2F;&#x2F;记录x最后一次出现的位置&#125;void get_ST(int n)&#123;    for (int j &#x3D; 1; (1 &lt;&lt; j) &lt;&#x3D; n; ++j)        for (int i &#x3D; 1; i + (1 &lt;&lt; j) - 1 &lt;&#x3D; n; ++i)        &#123;            int id1 &#x3D; st[i][j - 1], id2 &#x3D; st[i + (1 &lt;&lt; (j - 1))][j - 1];            if (dep[id1] &lt; dep[id2])                st[i][j] &#x3D; id1;            else                st[i][j] &#x3D; id2;        &#125;&#125;int rmq(int l, int r)&#123;    int d &#x3D; log2(r - l + 1);    int id1 &#x3D; st[l][d], id2 &#x3D; st[r - (1 &lt;&lt; d) + 1][d];    if (dep[id1] &lt; dep[id2])        return id1;    return id2;&#125;int main()&#123;    int temp;    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;temp);    int a, b;    for (int i &#x3D; 1; i &lt; n; i++)    &#123;        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);        son[a].push_back(b);        son[b].push_back(a);    &#125;    top &#x3D; 0;    dfs(temp, 1);    get_ST(top);    int x, y;    while (m--)    &#123;        scanf(&quot;%d%d&quot;, &amp;x, &amp;y);        if (first[x] &gt; first[y])            swap(x, y);        printf(&quot;%d\n&quot;, rmq(first[x], first[y]));    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tarjan强连通分量</title>
      <link href="/2022/08/31/tarjan-qiang-lian-tong-fen-liang/"/>
      <url>/2022/08/31/tarjan-qiang-lian-tong-fen-liang/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;vector&gt;using namespace std;int n,m;const int MAXN&#x3D;100010,MAXM&#x3D;1000010;&#x2F;&#x2F;链式前向星(new代表缩点后的图)int head[MAXN],ed[MAXM],nex[MAXM],idx;int head_new[MAXN],ed_new[MAXM],nex_new[MAXM],idx_new;int dfn[MAXN],low[MAXN],timestamp;&#x2F;&#x2F;dfn[i]表示遍历到i的时间戳,timestamp时间戳计数&#x2F;&#x2F;low[i]表示从i开始走(遍历它的子树),所能遍历到的最小时间戳是什么(i节点当前所在强连通块的最高点)int stk[MAXN],in_stk[MAXN],top;&#x2F;&#x2F;stk数组实现栈,top表示栈顶位置,in_stk[i]标记i是否在栈中int id[MAXN],scc_cnt,scc_size[MAXN];&#x2F;&#x2F;id[i]表示编号为i节点的强连通块编号&#x2F;&#x2F;scc_cnt表示强连通分量的个数,scc_size[i]表示编号为i的强连通分量中点的个数vector&lt;int&gt; scc[MAXN];&#x2F;&#x2F;scc[i]存储编号为i的强连通分量中的点void init()&#x2F;&#x2F;初始化&#123;    idx&#x3D;idx_new&#x3D;scc_cnt&#x3D;top&#x3D;0;    memset(head,-1,sizeof(head));    memset(head_new,-1,sizeof(head_new));&#125;void add(int a,int b)&#x2F;&#x2F;建立原图&#123;    ed[idx]&#x3D;b;    nex[idx]&#x3D;head[a];    head[a]&#x3D;idx++;&#125;void add_new(int a,int b)&#x2F;&#x2F;建立缩点图&#123;    ed_new[idx_new]&#x3D;b;    nex_new[idx_new]&#x3D;head_new[a];    head_new[a]&#x3D;idx_new++;&#125;void tarjan(int u)&#x2F;&#x2F;tarjan算法(采用数组栈实现)&#123;    dfn[u]&#x3D;low[u]&#x3D;++timestamp;&#x2F;&#x2F;初始化(第一次访问赋值新的时间戳)    stk[++top]&#x3D;u,in_stk[u]&#x3D;1;&#x2F;&#x2F;入栈操作,同时标记u在栈中        for(int i&#x3D;head[u];i!&#x3D;-1;i&#x3D;nex[i])&#x2F;&#x2F;遍历u的所有出边    &#123;        int j&#x3D;ed[i];&#x2F;&#x2F;u的一条出边的终点        if(dfn[j]&#x3D;&#x3D;0)&#x2F;&#x2F;当前点没有遍历        &#123;            tarjan(j);             &#x2F;&#x2F;j也许存在反向边到达比u还高的层,             &#x2F;&#x2F;所以用j能到的最小dfn序(最高点)更新u能达到的(最小dfn序)最高点            low[u]&#x3D;min(low[u],low[j]);&#x2F;&#x2F;更新low[u],注意此处是low[j]        &#125;        else if(in_stk[j]&#x3D;&#x3D;1)&#x2F;&#x2F;j在栈中            low[u]&#x3D;min(low[u],dfn[j]);&#x2F;&#x2F;更新low[u],注意此处是dfn[j]    &#125;    &#x2F;&#x2F;回到了强连通块的最高点,那么就将这个强连通块的所有节点进行缩点    if(low[u]&#x3D;&#x3D;dfn[u])    &#123;        scc_cnt++;&#x2F;&#x2F;强连通分量个数+1        int y;        do&#123;            y&#x3D;stk[top--];&#x2F;&#x2F;出栈            in_stk[y]&#x3D;0;&#x2F;&#x2F;标记清0            id[y]&#x3D;scc_cnt;&#x2F;&#x2F;赋值当前y的强连通分量的编号            scc_size[scc_cnt]++;&#x2F;&#x2F;size++            scc[scc_cnt].push_back(y);&#x2F;&#x2F;将点放入scc[scc_cnt]        &#125;while(u!&#x3D;y);            &#125;    &#125;int main()&#123;    init();    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);    for(int i&#x3D;1;i&lt;&#x3D;m;i++)    &#123;        int a,b;        scanf(&quot;%d %d&quot;,&amp;a,&amp;b);        add(a,b);    &#125;        for(int i&#x3D;1;i&lt;&#x3D;n;i++)        if(dfn[i]&#x3D;&#x3D;0)&#x2F;&#x2F;当前未搜索过            tarjan(i);        cout &lt;&lt; scc_cnt &lt;&lt; endl;&#x2F;&#x2F;输出强连通分量的个数        &#x2F;&#x2F;输出每个强连图分量的点    for(int i&#x3D;1;i&lt;&#x3D;scc_cnt;i++)    &#123;        for(int j&#x3D;scc[i].size()-1;j&gt;&#x3D;0;j--)            cout &lt;&lt; scc[i][j] &lt;&lt; &quot; &quot;;        cout &lt;&lt; endl;    &#125;    &#x2F;&#x2F;缩点操作    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#x2F;&#x2F;枚举每一个点        for(int j&#x3D;head[i];j!&#x3D;-1;j&#x3D;nex[j])&#x2F;&#x2F;枚举i的每一条边        &#123;            int k&#x3D;ed[j];            if(id[i]!&#x3D;id[k])&#x2F;&#x2F;强连通分量的编号不同连接该边                add_new(id[i],id[k]);        &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字典树</title>
      <link href="/2022/08/31/zi-dian-shu/"/>
      <url>/2022/08/31/zi-dian-shu/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;#include &lt;cstring&gt;#define MAXN 100010using namespace std;char op,str[MAXN];int trie[MAXN][26],idx&#x3D;0;&#x2F;&#x2F;此处以小写字符(a~z)为例int cnt[MAXN],vis[MAXN];&#x2F;&#x2F;cnt用来记录该字符串末尾出现次数;&#x2F;&#x2F;vis用来记录是否存在该字符串void insert(char *s)&#x2F;&#x2F;插入字符串&#123;    int p&#x3D;0;&#x2F;&#x2F;指向根结点    int len&#x3D;strlen(s);    for(int i&#x3D;0;i&lt;&#x3D;len-1;i++)&#x2F;&#x2F;遍历字符串s所有字符    &#123;        int u&#x3D;s[i]-&#39;a&#39;;        if(trie[p][u]&#x3D;&#x3D;0)&#x2F;&#x2F;当前结点为空,新建            trie[p][u]&#x3D;++idx;        p&#x3D;trie[p][u];    &#125;    cnt[p]++;&#x2F;&#x2F;记录该字符串末尾出现的次数    vis[p]&#x3D;1;&#x2F;&#x2F;为查询是否存在出现该字符串做准备,也可根据cnt数组判断&#125;int query(char *s)&#x2F;&#x2F;查询字符串出现次数（或查询字符串是否出现过）&#123;    int p&#x3D;0;    int len&#x3D;strlen(s);    for(int i&#x3D;0;i&lt;&#x3D;len-1;i++)    &#123;        int u&#x3D;s[i]-&#39;a&#39;;        if(trie[p][u]&#x3D;&#x3D;0)            return 0;&#x2F;&#x2F;不存在        p&#x3D;trie[p][u];    &#125;    return cnt[p];    &#x2F;&#x2F;return vis[p];&#125;int n;int main()&#123;    cin &gt;&gt; n;    while(n--)    &#123;        cin &gt;&gt; op &gt;&gt; str;        if(op&#x3D;&#x3D;&#39;I&#39;)            insert(str);        else printf(&quot;%d\n&quot;,query(str));    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉堆</title>
      <link href="/2022/08/31/er-cha-dui-ha-fu-man-shu/"/>
      <url>/2022/08/31/er-cha-dui-ha-fu-man-shu/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int SIZE&#x3D;10010;int n&#x3D;12,heap[SIZE]&#x3D;&#123;0,25,14,19,5,12,17,8,1,3,10,6,2&#125;;void up(int p)&#x2F;&#x2F;向上调整&#123;    while(p&gt;1)    &#123;        if(heap[p]&gt;heap[p&#x2F;2])&#x2F;&#x2F;当前结点大于父结点,交换;反之,不交换            swap(heap[p],heap[p&#x2F;2]),p&#x2F;&#x3D;2;        else break;    &#125;&#125;void Insert(int val)&#x2F;&#x2F;插入val&#123;    heap[++n]&#x3D;val;    up(n);&#125;int GetTop()&#x2F;&#x2F;查询最值&#123;    return heap[1];&#125;void down(int p)&#x2F;&#x2F;向下调整&#123;    int s&#x3D;p*2;&#x2F;&#x2F;p的左结点    while(s&lt;&#x3D;n)    &#123;        if(s&lt;n&amp;&amp;heap[s]&lt;heap[s+1])&#x2F;&#x2F;左右子结点中选取较大值            s++;        if(heap[s]&gt;heap[p])        &#123;            swap(heap[s],heap[p]);            p&#x3D;s;            s&#x3D;p*2;        &#125;        else break;    &#125;&#125;void Extract()&#x2F;&#x2F;删除堆顶元素&#123;    heap[1]&#x3D;heap[n--];    down(1);&#125;void Remove(int k)&#x2F;&#x2F;删除二叉堆中第k个元素&#123;    heap[k]&#x3D;heap[n--];    up(k);    down(k);&#125;int main()&#123;    &#x2F;&#x2F;Insert(20);    &#x2F;&#x2F;Extract();    Remove(3);    for(int i&#x3D;1;i&lt;&#x3D;n;i++)        printf(&quot;%d %d\n&quot;,i,heap[i]);    printf(&quot;%d\n&quot;,GetTop());    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>马拉车</title>
      <link href="/2022/08/31/ma-la-che/"/>
      <url>/2022/08/31/ma-la-che/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;#include &lt;cstring&gt;#define MAXN 20000010using namespace std;int len,p[MAXN];&#x2F;&#x2F;变形后字符串的长度char b[MAXN];&#x2F;&#x2F;存变形后的字符串string s;&#x2F;&#x2F;原始字符串void init()&#123;    len&#x3D;0;    b[len++]&#x3D;&#39;!&#39;;&#x2F;&#x2F;起点哨兵    b[len++]&#x3D;&#39;#&#39;;    for(int i&#x3D;0;i&lt;s.size();i++)    &#123;        b[len++]&#x3D;s[i];        b[len++]&#x3D;&#39;#&#39;;    &#125;    b[len++]&#x3D;&#39;@&#39;;&#x2F;&#x2F;末尾哨兵&#125;int manacher()&#123;    int rt&#x3D;0,mid&#x3D;0,res&#x3D;0;    for(int i&#x3D;1;i&lt;&#x3D;len-2;i++)    &#123;        if(i&lt;rt)            p[i]&#x3D;min(p[2*mid-i],rt-i);        else p[i]&#x3D;1;        while(b[i+p[i]]&#x3D;&#x3D;b[i-p[i]])        &#x2F;&#x2F;以i为中心p[i]为半径不断往外扩展,如果相等继续扩展            p[i]++;        if(i+p[i]&gt;rt)&#x2F;&#x2F;如果以i为中心的最大回文串能更新rt        &#123;            rt&#x3D;i+p[i];            mid&#x3D;i;&#x2F;&#x2F;更新rt对应的mid        &#125;        res&#x3D;max(res,p[i]-1);&#x2F;&#x2F;注意此处是p[i]-1    &#125;    return res;   &#125;int main()&#123;    cin &gt;&gt; s;    init();    &#x2F;&#x2F;cout &lt;&lt; b &lt;&lt; endl;    cout &lt;&lt; manacher() &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kmp</title>
      <link href="/2022/08/31/kmp/"/>
      <url>/2022/08/31/kmp/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define ull unsigned long long#define ll long long#define js ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)using namespace std;char s[10005],s1[1000005];int len,len1,Next[10005];void getNext()&#123;    int i&#x3D;0,j&#x3D;-1;    Next[0]&#x3D;-1;    while(i&lt;len)    &#123;        if(j&#x3D;&#x3D;-1||s[i]&#x3D;&#x3D;s[j])            Next[++i]&#x3D;++j;        else            j&#x3D;Next[j];    &#125;&#125;int kmp()&#123;    int j&#x3D;0,i&#x3D;0,ans&#x3D;0;    while(i&lt;len1)    &#123;        if(j&#x3D;&#x3D;-1||s1[i]&#x3D;&#x3D;s[j])            j++,i++;        else            j&#x3D;Next[j];        if(j&#x3D;&#x3D;len)        &#123;            ans++;            j&#x3D;Next[j];        &#125;    &#125;    return ans;&#125;int main()&#123;    js;    int t;    cin&gt;&gt;t;    while(t--)    &#123;        cin&gt;&gt;s&gt;&gt;s1;        len&#x3D;strlen(s);        len1&#x3D;strlen(s1);        getNext();        cout&lt;&lt;kmp()&lt;&lt;&#39;\n&#39;;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈希</title>
      <link href="/2022/08/30/ha-xi/"/>
      <url>/2022/08/30/ha-xi/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-none"><code class="language-none">const int MAXN&#x3D;100010,P&#x3D;131,M&#x3D;1e9+7;typedef unsigned long long ull;typedef long long ll;char s[MAXN];&#x2F;&#x2F;已知字符串s从1开始存储ull Hash1[MAXN],p1[MAXN];&#x2F;&#x2F;此处用自动取模ll Hash2[MAXN],p2[MAXN];&#x2F;&#x2F;此处采用单Hash方法&#x2F;&#x2F;Hash1和Hash2共同构成双Hash方法 p1[0]&#x3D;p2[0]&#x3D;1;int len&#x3D;strlen(s+1);for(int i&#x3D;1;i&lt;&#x3D;len;i++)&#123;&#x2F;&#x2F;此处为了方便,字符串的字符分配值就是该字符的ascii码p1[i]&#x3D;p1[i-1]*P;&#x2F;&#x2F;求P的次方Hash1[i]&#x3D;Hash1[i-1]*P+s[i];&#x2F;&#x2F;利用类似前缀和的思想求Hashp2[i]&#x3D;((p2[i-1]%M)*P)%M;&#x2F;&#x2F;(nm)%mod&#x3D;(n%mod * m%mod) %mod;Hash2[i]&#x3D;(((Hash2[i-1]%M)*P)%M+s[i])%M;&#125;&#x2F;&#x2F;求任意字串的哈希值ull get_hash1(int l,int r)&#123;return Hash1[r]-Hash1[l-1]*p1[r-l+1];&#125; ll get_hash2(int l,int r)&#123;return ((Hash2[r]-Hash2[l-1]*p2[r-l+1])%M+M)%M;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集</title>
      <link href="/2022/08/30/bing-cha-ji/"/>
      <url>/2022/08/30/bing-cha-ji/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;银河英雄传说#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN&#x3D;30010;int t;int fa[MAXN],d[MAXN],siz[MAXN];void init()&#123;    for(int i&#x3D;1;i&lt;MAXN;i++)        fa[i]&#x3D;i,siz[i]&#x3D;1;&#x2F;&#x2F;初始化时siz每个集合只有1个&#125;int find(int x)&#123;    if(x&#x3D;&#x3D;fa[x])    return x;    int root&#x3D;find(fa[x]);&#x2F;&#x2F;递归计算集合代表    d[x]+&#x3D;d[fa[x]];&#x2F;&#x2F;维护d数组,对边权求和    return fa[x]&#x3D;root;&#x2F;&#x2F;路径压缩&#125;void join(int x,int y)&#123;    int fx&#x3D;find(x),fy&#x3D;find(y);    if(fx!&#x3D;fy)    &#123;        fa[fx]&#x3D;fy,d[fx]&#x3D;siz[fy];        siz[fy]+&#x3D;siz[fx];    &#125;&#125;int main()&#123;    init();    scanf(&quot;%d\n&quot;,&amp;t);    while(t--)    &#123;        int a,b;        char op;        scanf(&quot;%c %d %d &quot;,&amp;op,&amp;a,&amp;b);        if(op&#x3D;&#x3D;&#39;M&#39;)&#x2F;&#x2F;合并            join(a,b);        else&#x2F;&#x2F;查询        &#123;            if(a&#x3D;&#x3D;b)                printf(&quot;0\n&quot;);            else if(find(a)&#x3D;&#x3D;find(b))                printf(&quot;%d\n&quot;,abs(d[a]-d[b])-1);            else printf(&quot;-1\n&quot;);        &#125;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双向广搜</title>
      <link href="/2022/08/30/shuang-xiang-guang-sou/"/>
      <url>/2022/08/30/shuang-xiang-guang-sou/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-none"><code class="language-none">void BFS_expand(queue&lt;Status&gt;&amp; Q,int flag)&#123;    Status s&#x3D;Q.front();&#x2F;&#x2F;从队列中得到头结点       Q.pop();    for(每个s的子结点t)&#123;        t.state&#x3D;Get_state(t);&#x2F;&#x2F;获取子结点的状态        if(flag&#x3D;&#x3D;1)&#123;&#x2F;&#x2F;正向队列中判断            if(vis[t.state]!&#x3D;1)&#123;&#x2F;&#x2F;没有在正向队列中出现过                if(vis[t.state]&#x3D;&#x3D;2)&#123;&#x2F;&#x2F;该状态在反向队列中出现过                    &#x2F;&#x2F;各种操作  found&#x3D;1;                    return ;                &#125;                vis[t.state]&#x3D;1;&#x2F;&#x2F;标记为在正向队列中   Q.push(t);            &#125;        &#125;        else&#x2F;&#x2F;在反向队列中判断&#123;            if(vis[t.state]!&#x3D;2)&#123;&#x2F;&#x2F;没有在反向队列出现过                if(vis[t.state]&#x3D;&#x3D;1)&#123;&#x2F;&#x2F;该状态在正向队列中出现过                    &#x2F;&#x2F;各种操作  found&#x3D;1;                    return ;                &#125;                vis[t.state]&#x3D;2;&#x2F;&#x2F;标记为在反向队列中   Q.push(t);            &#125;        &#125;            &#125;&#125;int found;void DBFS()&#x2F;&#x2F;双向广搜&#123;    found&#x3D;false;    memset(vis,0,sizeof(vis));&#x2F;&#x2F;判重数组    while(Q1.size()&gt;0)  Q1.pop();&#x2F;&#x2F;正向队列        while(Q2.size()&gt;0)  Q2.pop();&#x2F;&#x2F;反向队列    &#x2F;&#x2F;正向扩展的状态标记为1,反向扩展标记为2    vis[s1]&#x3D;1;&#x2F;&#x2F;初始状态s1标记为1    vis[s2]&#x3D;2;&#x2F;&#x2F;结束状态s2标记为2    Q1.push(s1.state);&#x2F;&#x2F;初始状态入正向队列    Q2.push(s2.state);&#x2F;&#x2F;结束状态入反向队列    while(Q1.size()&gt;0||Q2.size()&gt;0)&#123;        if(Q1.size()&gt;0)            BFS_expand(Q1,1);&#x2F;&#x2F;在正向队列中搜索        if(found&#x3D;&#x3D;1)&#x2F;&#x2F;搜索结束            return ;        if(Q2.size()&gt;0)            BFS_expand(Q2,0);&#x2F;&#x2F;在反向队列中搜索        if(found&#x3D;&#x3D;1)&#x2F;&#x2F;搜索结束            return ;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单调队列滑动窗口</title>
      <link href="/2022/08/30/dan-diao-dui-lie-hua-dong-chuang-kou/"/>
      <url>/2022/08/30/dan-diao-dui-lie-hua-dong-chuang-kou/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;const int MAXN&#x3D;1000010;int n,k,a[MAXN];deque&lt;int&gt; dq1,dq2;int main()&#123;    scanf(&quot;%d %d&quot;,&amp;n,&amp;k);    &#x2F;&#x2F;求最小值,使用单调递增队列    for(int i&#x3D;0;i&lt;&#x3D;n-1;i++)    &#123;        scanf(&quot;%d&quot;,&amp;a[i]);        if(dq1.size()&gt;0&amp;&amp;dq1.front()&lt;&#x3D;i-k)&#x2F;&#x2F;处理滑动窗口左端            dq1.pop_front();&#x2F;&#x2F;弹出队头        while(dq1.size()&gt;0&amp;&amp;a[i]&lt;&#x3D;a[dq1.back()])&#x2F;&#x2F;把大于等于入队元素在队列中的值都剔除            dq1.pop_back();        dq1.push_back(i);&#x2F;&#x2F;将该元素的下标放入队列中        if(i&gt;&#x3D;k-1)&#x2F;&#x2F;达到区间长度输出队头元素,此处也可存入数组中,全部处理完再输出            printf(&quot;%d &quot;,a[dq1.front()]);    &#125;    printf(&quot;\n&quot;);    &#x2F;&#x2F;求最大值,使用单调递减队列    for(int i&#x3D;0;i&lt;&#x3D;n-1;i++)    &#123;        if(dq2.size()&gt;0&amp;&amp;dq2.front()&lt;&#x3D;i-k)&#x2F;&#x2F;处理滑动窗口左端            dq2.pop_front();        while(dq2.size()&gt;0&amp;&amp;a[i]&gt;&#x3D;a[dq2.back()])&#x2F;&#x2F;把小于等于入队元素在队列中的值都剔除            dq2.pop_back();        dq2.push_back(i);&#x2F;&#x2F;将该元素的下标放入队列中        if(i&gt;&#x3D;k-1)&#x2F;&#x2F;达到区间长度输出队头元素            printf(&quot;%d &quot;,a[dq2.front()]);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单调栈</title>
      <link href="/2022/08/30/dan-diao-zhan/"/>
      <url>/2022/08/30/dan-diao-zhan/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-none"><code class="language-none">stack&lt;int&gt; sta;&#x2F;&#x2F;此处以单调递增栈为例for(遍历需要入栈的数组)&#123;     if( 栈空 || 栈顶元素小于入栈元素)        &#123;         &#x2F;&#x2F;更新结果;         入栈元素入栈;     &#125;     else      &#123;         while( 栈不为空 &amp;&amp; 栈顶元素大于等于入栈元素)         &#123;             栈顶元素出栈;             更新结果;         &#125;         入栈元素入栈;     &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法c++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
